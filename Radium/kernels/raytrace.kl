struct Ray
{
	float3 origin;
	float3 direction;
};

struct Sphere
{
	float3 position;
	float3 color;
	float radius;
};

void SetColor(global char* buffer, int index, char r, char g, char b, char a)
{
	buffer[index] = b;
	buffer[index + 1] = g;
    buffer[index + 2] = r;
    buffer[index + 3] = a;
}

bool IntersectSphere(struct Sphere* s, struct Ray* r, float* t)
{
	float3 rayToCenter = s->position - r->origin;
	float dotProduct = dot(r->direction, rayToCenter);
	float d = dotProduct * dotProduct - dot(rayToCenter, rayToCenter) + s->radius * s->radius;

	if (d < 0)
	{
		return false;
	}

	*t = dotProduct - sqrt(d);

	if (*t < 0)
	{
		*t = dotProduct + sqrt(d);

		if (*t < 0)
		{
			return false;
		}
	}

	return true;
}

void getSpheres(global float* data, struct Sphere* spheres, int count)
{
	int index = 0;
	for (int i = 0; i < count; i++)
	{
		float3 spherePosition = { data[index], data[index + 1], data[index + 2] };
		float radius = data[index + 3];
		float3 color = { data[index + 4], data[index + 5], data[index + 6]};

		spheres[i].position = spherePosition;
		spheres[i].radius = radius;
		spheres[i].color = color;

		index += 7;
	}
}

kernel void raytrace(
	const unsigned int width,
	const unsigned int height,
	const unsigned int sphereCount,
    global char* buffer,
	global float* spheres,
	global float* camera)
{
    int xDim = get_global_id(0);
    int yDim = get_global_id(1);
    int index = (4 * width * yDim) + (xDim * 4);

	struct Sphere readSpheres[2];
	getSpheres(spheres, readSpheres, sphereCount);

	float3 cameraPosition = { camera[0], camera[1], camera[2] };
	float3 cameraDirection = { camera[3], camera[4], camera[5] };

	float dx = 1.0f / (float)(width);
	float dy = 1.0f / (float)(height);
	float aspect = (float)(width) / (float)(height);

	float3 rayOrigin = { (cameraPosition.x + dx * (float)(xDim) - 0.5f) * aspect, cameraPosition.y - dy * (float)(yDim) + 0.5f, cameraPosition.z };

	struct Ray cameraRay;
	cameraRay.origin = rayOrigin;
	cameraRay.direction = cameraDirection;

	SetColor(buffer, index, 255, 255, 255, 255);
	
	int intersectIndex = -1;
	float minIntersect = 1000000;

	for (int i = 0; i < sphereCount; i++)
	{
		float t = 0;
		bool intersect = IntersectSphere(&readSpheres[i], &cameraRay, &t);

		if (intersect)
		{
			if (t < minIntersect)
			{
				minIntersect = t;
				intersectIndex = i;
			}
		}
	}

	if (intersectIndex > -1)
	{
		SetColor(
			buffer, 
			index, 
			readSpheres[intersectIndex].color.x, 
			readSpheres[intersectIndex].color.y, 
			readSpheres[intersectIndex].color.z, 
			255);
	}
}